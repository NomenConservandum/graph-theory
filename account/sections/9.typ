= Веса IV b
== Условие
Вывести длины кратчайших путей для всех пар вершин.

== код (фрагменты кода)
```
func floydWarshallSimple(g *GraphInfo) (map[*Node]map[*Node]float64, bool) {
	// Инициализация матрицы расстояний
	dist := make(map[*Node]map[*Node]float64)

	// Инициализация для всех вершин
	for _, u := range g.nodes {
		dist[u] = make(map[*Node]float64)
		for _, v := range g.nodes {
			if u == v {
				dist[u][v] = 0
			} else {
				dist[u][v] = math.Inf(1) // Бесконечность
			}
		}
	}

	// Заполнение начальных расстояний из рёбер графа
	for u, edges := range g.connectionsList {
		for _, edge := range edges {
			v := edge.List[1]
			weight := edge.Weight

			// Если граф невзвешенный, используем вес 1
			if !g.isWeighted {
				weight = 1
			}

			if weight < dist[u][v] {
				dist[u][v] = weight
			}
		}
	}

	// Основной алгоритм Флойда-Уоршелла
	for _, k := range g.nodes {
		for _, i := range g.nodes {
			for _, j := range g.nodes {
				if dist[i][k] < math.Inf(1) && dist[k][j] < math.Inf(1) {
					if dist[i][j] > dist[i][k]+dist[k][j] {
						dist[i][j] = dist[i][k] + dist[k][j]
					}
				}
			}
		}
	}

	// Проверка на отрицательные циклы
	hasNegativeCycle := false
	for _, i := range g.nodes {
		if dist[i][i] < 0 {
			hasNegativeCycle = true
			break
		}
	}

	return dist, hasNegativeCycle
}
```

== краткое описание алгоритма
=== Что делает
- Находит *кратчайшие расстояния между всеми парами вершин* в графе
- Обнаруживает *наличие циклов отрицательного веса*
- Возвращает *матрицу расстояний* и флаг наличия отрицательных циклов

=== Алгоритм
1. Инициализация: расстояния $0$ для $i = j$, $infinity$ для остальных, веса рёбер
2. Тройной цикл: для каждой тройки вершин $(i, j, k)$ улучшаем оценку $d i s t [i][j]$
3. Проверка отрицательных циклов: если $d i s t [i][i] < 0$, есть отрицательный цикл


=== Сложность
- Временная сложность: $O(V^3)$
  - $V$ - количество вершин
  - Три вложенных цикла по $V$: $O(V × V × V)$

/*
**Ключевые особенности:**
1. **Динамическое программирование**: постепенное улучшение оценок расстояний
2. **Работает с любыми графами** (ориентированными/неориентированными, взвешенными)
3. **Обрабатывает отрицательные веса** (но не отрицательные циклы)
4. **Обнаруживает отрицательные циклы** через диагональ матрицы
*/

/*
**Преимущества:**
- Простая реализация
- Работает с отрицательными весами
- Находит все попарные расстояния

**Недостатки:**
- Высокая сложность O(V³) - не подходит для больших графов
- Не восстанавливает сами пути (только расстояния)

**Применение:**
- Малые и средние графы (до ~1000 вершин)
- Плотные графы
- Когда нужны все попарные расстояния
*/
== примеры входных и выходных данных
=== Входные данные
```
TYPE: DIRECTED WEIGHTED
VERTICES: A,B,C,D
EDGES:
A->B: 3
A->C: 8
A->D: 2
B->C: 1
B->D: 4
C->D: 2
D->B: 1
```

=== Выходные данные
```
=== Floyd-Warshall algorithm - Minimal Distances Between Each Pair of Vertices ===

Shortest Paths Matrix:
         A    B    C    D
    A  0.0  3.0  4.0  2.0
    B  INF  0.0  1.0  3.0
    C  INF  3.0  0.0  2.0
    D  INF  1.0  2.0  0.0
```